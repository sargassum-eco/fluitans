// Package zerotier provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package zerotier

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// ControllerNetwork defines model for ControllerNetwork.
type ControllerNetwork struct {
	Capabilities      *[]map[string]interface{} `json:"capabilities,omitempty"`
	CreationTime      *float32                  `json:"creationTime,omitempty"`
	EnableBroadcast   *bool                     `json:"enableBroadcast,omitempty"`
	Id                *string                   `json:"id,omitempty"`
	IpAssignmentPools *[]IpAssignmentPool       `json:"ipAssignmentPools,omitempty"`
	Mtu               *int                      `json:"mtu,omitempty"`
	MulticastLimit    *int                      `json:"multicastLimit,omitempty"`
	Name              *string                   `json:"name,omitempty"`
	Nwid              *string                   `json:"nwid,omitempty"`
	Objtype           *string                   `json:"objtype,omitempty"`
	Private           *bool                     `json:"private,omitempty"`
	RemoteTraceLevel  *int                      `json:"remoteTraceLevel,omitempty"`
	RemoteTraceTarget *string                   `json:"remoteTraceTarget,omitempty"`
	Revision          *int                      `json:"revision,omitempty"`
	Routes            *[]Route                  `json:"routes,omitempty"`
	Rules             *[]map[string]interface{} `json:"rules,omitempty"`
	Tags              *[]map[string]interface{} `json:"tags,omitempty"`
	V4AssignMode      *V4AssignMode             `json:"v4AssignMode,omitempty"`
	V6AssignMode      *V6AssignMode             `json:"v6AssignMode,omitempty"`
}

// ControllerNetworkMember defines model for ControllerNetworkMember.
type ControllerNetworkMember struct {
	ActiveBridge  *bool     `json:"activeBridge,omitempty"`
	Address       *string   `json:"address,omitempty"`
	Authorized    *bool     `json:"authorized,omitempty"`
	Id            *string   `json:"id,omitempty"`
	Identity      *string   `json:"identity,omitempty"`
	IpAssignments *[]string `json:"ipAssignments,omitempty"`
	Nwid          *string   `json:"nwid,omitempty"`
	Revision      *int      `json:"revision,omitempty"`
	VMajor        *int      `json:"vMajor,omitempty"`
	VMinor        *int      `json:"vMinor,omitempty"`
	VProto        *int      `json:"vProto,omitempty"`
	VRev          *int      `json:"vRev,omitempty"`
}

// ControllerStatus defines model for ControllerStatus.
type ControllerStatus struct {
	ApiVersion *int   `json:"apiVersion,omitempty"`
	Clock      *int64 `json:"clock,omitempty"`
	Controller *bool  `json:"controller,omitempty"`
}

// IpAssignmentPool defines model for IpAssignmentPool.
type IpAssignmentPool struct {
	IpRangeEnd   *string `json:"ipRangeEnd,omitempty"`
	IpRangeStart *string `json:"ipRangeStart,omitempty"`
}

// Network defines model for Network.
type Network struct {
	// Let ZeroTier modify the system's DNS settings.
	AllowDNS *bool `json:"allowDNS,omitempty"`

	// Let ZeroTier modify the system's default route.
	AllowDefault *bool `json:"allowDefault,omitempty"`

	// Let ZeroTier manage IP addresses and Route assignments that aren't in private ranges (rfc1918).
	AllowGlobal *bool `json:"allowGlobal,omitempty"`

	// Let ZeroTier to manage IP addresses and Route assignments.
	AllowManaged      *bool     `json:"allowManaged,omitempty"`
	AssignedAddresses *[]string `json:"assignedAddresses,omitempty"`
	Bridge            *bool     `json:"bridge,omitempty"`
	BroadcastEnabled  *bool     `json:"broadcastEnabled,omitempty"`
	Dns               *struct {
		Domain  *string   `json:"domain,omitempty"`
		Servers *[]string `json:"servers,omitempty"`
	} `json:"dns,omitempty"`
	Id *string `json:"id,omitempty"`

	// MAC address for this network's interface.
	Mac                    *string `json:"mac,omitempty"`
	Mtu                    *int    `json:"mtu,omitempty"`
	MulticastSubscriptions *[]struct {
		Adi *int64  `json:"adi,omitempty"`
		Mac *string `json:"mac,omitempty"`
	} `json:"multicastSubscriptions,omitempty"`
	Name            *string `json:"name,omitempty"`
	NetconfRevision *int    `json:"netconfRevision,omitempty"`
	PortDeviceName  *string `json:"portDeviceName,omitempty"`
	PortError       *int    `json:"portError,omitempty"`
	Routes          *[]struct {
		Flags  *int    `json:"flags,omitempty"`
		Metric *int    `json:"metric,omitempty"`
		Target *string `json:"target,omitempty"`
		Via    *string `json:"via,omitempty"`
	} `json:"routes,omitempty"`
	Status *string `json:"status,omitempty"`
	Type   *string `json:"type,omitempty"`
}

// Peer defines model for Peer.
type Peer struct {
	Address  *string `json:"address,omitempty"`
	IsBonded *bool   `json:"isBonded,omitempty"`
	Latency  *int    `json:"latency,omitempty"`
	Paths    *[]struct {
		Active        *bool   `json:"active,omitempty"`
		Address       *string `json:"address,omitempty"`
		Expired       *bool   `json:"expired,omitempty"`
		LastReceive   *int64  `json:"lastReceive,omitempty"`
		LastSend      *int64  `json:"lastSend,omitempty"`
		Preferred     *bool   `json:"preferred,omitempty"`
		TrustedPathId *int    `json:"trustedPathId,omitempty"`
	} `json:"paths,omitempty"`
	Role         *string `json:"role,omitempty"`
	Version      *string `json:"version,omitempty"`
	VersionMajor *int    `json:"versionMajor,omitempty"`
	VersionMinor *int    `json:"versionMinor,omitempty"`
	VersionRev   *int    `json:"versionRev,omitempty"`
}

// Route defines model for Route.
type Route struct {
	Target *string `json:"target,omitempty"`
	Via    *string `json:"via"`
}

// Status defines model for Status.
type Status struct {
	Address *string `json:"address,omitempty"`
	Clock   *int64  `json:"clock,omitempty"`
	Config  *struct {
		Settings *struct {
			AllowTcpFallbackRelay *bool `json:"allowTcpFallbackRelay,omitempty"`
			PortMappingEnabled    *bool `json:"portMappingEnabled,omitempty"`
			PrimaryPort           *int  `json:"primaryPort,omitempty"`
		} `json:"settings,omitempty"`
	} `json:"config,omitempty"`
	Online               *bool   `json:"online,omitempty"`
	PlanetWorldId        *int64  `json:"planetWorldId,omitempty"`
	PlanetWorldTimestamp *int64  `json:"planetWorldTimestamp,omitempty"`
	PublicIdentity       *string `json:"publicIdentity,omitempty"`
	TcpFallbackActive    *bool   `json:"tcpFallbackActive,omitempty"`
	Version              *string `json:"version,omitempty"`
	VersionBuild         *int    `json:"versionBuild,omitempty"`
	VersionMajor         *int    `json:"versionMajor,omitempty"`
	VersionMinor         *int    `json:"versionMinor,omitempty"`
	VersionRev           *int    `json:"versionRev,omitempty"`
}

// V4AssignMode defines model for V4AssignMode.
type V4AssignMode struct {
	Zt *bool `json:"zt,omitempty"`
}

// V6AssignMode defines model for V6AssignMode.
type V6AssignMode struct {
	N6plane *bool `json:"6plane,omitempty"`
	Rfc4193 *bool `json:"rfc4193,omitempty"`
	Zt      *bool `json:"zt,omitempty"`
}

// GenerateControllerNetworkJSONBody defines parameters for GenerateControllerNetwork.
type GenerateControllerNetworkJSONBody = ControllerNetwork

// SetControllerNetworkJSONBody defines parameters for SetControllerNetwork.
type SetControllerNetworkJSONBody = ControllerNetwork

// SetControllerNetworkMemberJSONBody defines parameters for SetControllerNetworkMember.
type SetControllerNetworkMemberJSONBody = ControllerNetworkMember

// UpdateNetworkJSONBody defines parameters for UpdateNetwork.
type UpdateNetworkJSONBody = Network

// GenerateControllerNetworkJSONRequestBody defines body for GenerateControllerNetwork for application/json ContentType.
type GenerateControllerNetworkJSONRequestBody = GenerateControllerNetworkJSONBody

// SetControllerNetworkJSONRequestBody defines body for SetControllerNetwork for application/json ContentType.
type SetControllerNetworkJSONRequestBody = SetControllerNetworkJSONBody

// SetControllerNetworkMemberJSONRequestBody defines body for SetControllerNetworkMember for application/json ContentType.
type SetControllerNetworkMemberJSONRequestBody = SetControllerNetworkMemberJSONBody

// UpdateNetworkJSONRequestBody defines body for UpdateNetwork for application/json ContentType.
type UpdateNetworkJSONRequestBody = UpdateNetworkJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Controller Status.
	// (GET /controller)
	GetControllerStatus(ctx echo.Context) error
	// List Networks.
	// (GET /controller/network)
	GetControllerNetworks(ctx echo.Context) error
	// Generate Random Network ID.
	// (POST /controller/network/{controllerID}______)
	GenerateControllerNetwork(ctx echo.Context, controllerID string) error
	// Delete a network.
	// (DELETE /controller/network/{networkID})
	DeleteControllerNetwork(ctx echo.Context, networkID string) error
	// Get Network by ID.
	// (GET /controller/network/{networkID})
	GetControllerNetwork(ctx echo.Context, networkID string) error
	// Create or Update a Network.
	// (POST /controller/network/{networkID})
	SetControllerNetwork(ctx echo.Context, networkID string) error
	// List Network Members.
	// (GET /controller/network/{networkID}/member)
	GetControllerNetworkMembers(ctx echo.Context, networkID string) error
	// Remove a network member.
	// (DELETE /controller/network/{networkID}/member/{nodeID})
	DeleteControllerNetworkMember(ctx echo.Context, networkID string, nodeID string) error
	// Get Network Member Details by ID.
	// (GET /controller/network/{networkID}/member/{nodeID})
	GetControllerNetworkMember(ctx echo.Context, networkID string, nodeID string) error
	// Create or Update a Network Membership.
	// (POST /controller/network/{networkID}/member/{nodeID})
	SetControllerNetworkMember(ctx echo.Context, networkID string, nodeID string) error
	// Get all network memberships.
	// (GET /network)
	GetNetworks(ctx echo.Context) error
	// Leave a network.
	// (DELETE /network/{networkID})
	DeleteNetwork(ctx echo.Context, networkID string) error
	// Get a joined Network membership configuration by Network ID.
	// (GET /network/{networkID})
	GetNetwork(ctx echo.Context, networkID string) error
	// Join a network or update it's configuration by Network ID.
	// (POST /network/{networkID})
	UpdateNetwork(ctx echo.Context, networkID string) error
	// Get all peers.
	// (GET /peer)
	GetPeers(ctx echo.Context) error
	// Get information about a specific peer by Node ID.
	// (GET /peer/{address})
	GetPeer(ctx echo.Context, address string) error
	// Node status and addressing info.
	// (GET /status)
	GetStatus(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetControllerStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetControllerStatus(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetControllerStatus(ctx)
	return err
}

// GetControllerNetworks converts echo context to params.
func (w *ServerInterfaceWrapper) GetControllerNetworks(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetControllerNetworks(ctx)
	return err
}

// GenerateControllerNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GenerateControllerNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "controllerID" -------------
	var controllerID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "controllerID", runtime.ParamLocationPath, ctx.Param("controllerID"), &controllerID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter controllerID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GenerateControllerNetwork(ctx, controllerID)
	return err
}

// DeleteControllerNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteControllerNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "networkID" -------------
	var networkID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "networkID", runtime.ParamLocationPath, ctx.Param("networkID"), &networkID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter networkID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteControllerNetwork(ctx, networkID)
	return err
}

// GetControllerNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetControllerNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "networkID" -------------
	var networkID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "networkID", runtime.ParamLocationPath, ctx.Param("networkID"), &networkID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter networkID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetControllerNetwork(ctx, networkID)
	return err
}

// SetControllerNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) SetControllerNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "networkID" -------------
	var networkID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "networkID", runtime.ParamLocationPath, ctx.Param("networkID"), &networkID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter networkID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetControllerNetwork(ctx, networkID)
	return err
}

// GetControllerNetworkMembers converts echo context to params.
func (w *ServerInterfaceWrapper) GetControllerNetworkMembers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "networkID" -------------
	var networkID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "networkID", runtime.ParamLocationPath, ctx.Param("networkID"), &networkID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter networkID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetControllerNetworkMembers(ctx, networkID)
	return err
}

// DeleteControllerNetworkMember converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteControllerNetworkMember(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "networkID" -------------
	var networkID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "networkID", runtime.ParamLocationPath, ctx.Param("networkID"), &networkID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter networkID: %s", err))
	}

	// ------------- Path parameter "nodeID" -------------
	var nodeID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "nodeID", runtime.ParamLocationPath, ctx.Param("nodeID"), &nodeID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nodeID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteControllerNetworkMember(ctx, networkID, nodeID)
	return err
}

// GetControllerNetworkMember converts echo context to params.
func (w *ServerInterfaceWrapper) GetControllerNetworkMember(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "networkID" -------------
	var networkID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "networkID", runtime.ParamLocationPath, ctx.Param("networkID"), &networkID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter networkID: %s", err))
	}

	// ------------- Path parameter "nodeID" -------------
	var nodeID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "nodeID", runtime.ParamLocationPath, ctx.Param("nodeID"), &nodeID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nodeID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetControllerNetworkMember(ctx, networkID, nodeID)
	return err
}

// SetControllerNetworkMember converts echo context to params.
func (w *ServerInterfaceWrapper) SetControllerNetworkMember(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "networkID" -------------
	var networkID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "networkID", runtime.ParamLocationPath, ctx.Param("networkID"), &networkID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter networkID: %s", err))
	}

	// ------------- Path parameter "nodeID" -------------
	var nodeID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "nodeID", runtime.ParamLocationPath, ctx.Param("nodeID"), &nodeID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nodeID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetControllerNetworkMember(ctx, networkID, nodeID)
	return err
}

// GetNetworks converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworks(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetNetworks(ctx)
	return err
}

// DeleteNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "networkID" -------------
	var networkID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "networkID", runtime.ParamLocationPath, ctx.Param("networkID"), &networkID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter networkID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteNetwork(ctx, networkID)
	return err
}

// GetNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "networkID" -------------
	var networkID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "networkID", runtime.ParamLocationPath, ctx.Param("networkID"), &networkID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter networkID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetNetwork(ctx, networkID)
	return err
}

// UpdateNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "networkID" -------------
	var networkID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "networkID", runtime.ParamLocationPath, ctx.Param("networkID"), &networkID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter networkID: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateNetwork(ctx, networkID)
	return err
}

// GetPeers converts echo context to params.
func (w *ServerInterfaceWrapper) GetPeers(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPeers(ctx)
	return err
}

// GetPeer converts echo context to params.
func (w *ServerInterfaceWrapper) GetPeer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPeer(ctx, address)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/controller", wrapper.GetControllerStatus)
	router.GET(baseURL+"/controller/network", wrapper.GetControllerNetworks)
	router.POST(baseURL+"/controller/network/:controllerID______", wrapper.GenerateControllerNetwork)
	router.DELETE(baseURL+"/controller/network/:networkID", wrapper.DeleteControllerNetwork)
	router.GET(baseURL+"/controller/network/:networkID", wrapper.GetControllerNetwork)
	router.POST(baseURL+"/controller/network/:networkID", wrapper.SetControllerNetwork)
	router.GET(baseURL+"/controller/network/:networkID/member", wrapper.GetControllerNetworkMembers)
	router.DELETE(baseURL+"/controller/network/:networkID/member/:nodeID", wrapper.DeleteControllerNetworkMember)
	router.GET(baseURL+"/controller/network/:networkID/member/:nodeID", wrapper.GetControllerNetworkMember)
	router.POST(baseURL+"/controller/network/:networkID/member/:nodeID", wrapper.SetControllerNetworkMember)
	router.GET(baseURL+"/network", wrapper.GetNetworks)
	router.DELETE(baseURL+"/network/:networkID", wrapper.DeleteNetwork)
	router.GET(baseURL+"/network/:networkID", wrapper.GetNetwork)
	router.POST(baseURL+"/network/:networkID", wrapper.UpdateNetwork)
	router.GET(baseURL+"/peer", wrapper.GetPeers)
	router.GET(baseURL+"/peer/:address", wrapper.GetPeer)
	router.GET(baseURL+"/status", wrapper.GetStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"QAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
